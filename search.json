[{"categories":null,"content":"nanoId是什么？  官方描述：一个小巧、安全、URL友好、唯一的 JavaScript 字符串ID生成器。一般我拿来用于生成唯一id，官方也贴心的提供了一个计算碰撞率的网站，有兴趣可以去看看：地址\n 抛砖引玉 nanoId现在已经被移植到了20种语言中，这个系列文章将会就作者的JS实现，和Java实现为主要切入点。本篇是解读nano源码的第一篇文章。首先先简单热热身，先看一下项目中的demo是怎么实现的。\n小试牛刀 1 2  import { nanoid } from 'nanoid' model.id = nanoid() //=\u003e \"V1StGXR8_Z5jdHi6B-myT\"   我们能够看到，这个函数是从nanoid 中引用的。通过vscode的跳转帮助，我们能够看到文件如下所示：\n这个方法接受一个number类型的参数，作为size，返回字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * Generate secure URL-friendly unique ID. * * By default, the ID will have 21 symbols to have a collision probability * similar to UUID v4. * * ```js * import { nanoid } from 'nanoid' * model.id = nanoid() //=\u003e \"Uakgb_J5m9g-0JDMbcJqL\" * ``` * * @param size Size of the ID. The default size is 21. * @returns A random string. */ export function nanoid(size?: number): string   -= convert size to number 这时让我们去源码看一看作者的实现吧。这个方法位于nanoid项目根目录下的index.js文件里的nanoid 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  const POOL_SIZE_MULTIPLIER = 128 let pool, poolOffset let nanoid = (size = 21) =\u003e { // to prevent `valueOf` abusing  fillPool((size -= 0)) let id = '' // We are reading directly from the random pool to avoid creating new array  for (let i = poolOffset - size; i \u003c poolOffset; i++) { // It is incorrect to use bytes exceeding the alphabet size.  // The following mask reduces the random byte in the 0-255 value  // range to the 0-63 value range. Therefore, adding hacks, such  // as empty string fallback or magic numbers, is unneccessary because  // the bitmask trims bytes down to the alphabet size.  id += urlAlphabet[pool[i] \u0026 63] } return id let fillPool = bytes =\u003e { if (!pool || pool.length \u003c bytes) { pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER) crypto.randomFillSync(pool) poolOffset = 0 } else if (poolOffset + bytes \u003e pool.length) { crypto.randomFillSync(pool) poolOffset = 0 } poolOffset += bytes } }    这个方法关联的行数很少，但是作者也别有用心。\n 首先是为了避免valueOf的消耗，使用-= 运算符将size变量转换成 number 类型。 之后来到了fillPool方法，这里作者进行了判断。\n如果全局变量pool 不存在，或者，已存在的 池子大小比我们传入的size 小。 那我们就重新创建一个池子。反之就使用已存在的池子，减少一次 分配Buffer变量的消耗。 如果需要创建一个池子， 之后使用的是Buffer模块提供的allocUnsafe 方法。 这里便利用到了allocUnsafe的一个特性， 预分配Buffer。原因如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  The Buffer module pre-allocates an internal Buffer instance of size Buffer.poolSize that is used as a pool for the fast allocation of new Buffer instances created using Buffer.allocUnsafe(), Buffer.from(array), Buffer.concat(), and the deprecated new Buffer(size) constructor only when size is less than or equal to Buffer.poolSize \u003e\u003e 1 (floor of Buffer.poolSize divided by two). 这里介绍的是Buffer模块会预先创建一个 Buffer.poolSize大小（8192）的Buffer缓冲区， 并且只会在 Buffer.allocUnsafe(), Buffer.from(array), Buffer.concat(), 和废弃的 new Buffer(size) 这几个方法初始化的时候， 当它们传入的size 小于等于 Buffer.poolSize的 1/2的时候。才会利用到这个预创建Buffer缓冲区。 ---------------------------------------------------------------------------------------------------------- nodeJS 源码如下： /** * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer * instance. If `--zero-fill-buffers` is set, will zero-fill the buffer. */ Buffer.allocUnsafe = function allocUnsafe(size) { assertSize(size); return allocate(size); }; function allocate(size) { // 如果 未指定size或者size小于等于 pool.size的一半。直接使用预先分配的Buffer，这里传入的21*128=2688 \u003c=4096  // 因此使用 预缓冲区  if (size \u003c= 0) { return new FastBuffer(); } if (size \u003c (Buffer.poolSize \u003e\u003e\u003e 1)) { if (size \u003e (poolSize - poolOffset)) createPool(); const b = new FastBuffer(allocPool, poolOffset, size); poolOffset += size; alignPool(); return b; } return createUnsafeBuffer(size); }   在生成Buffer缓冲区之后，使用crypto模块对空缓冲区进行了填充。之后来到方法的最后一部分。遍历生成字符。这里使用的63是有意义的。因为通过IDE的跳转，我们可以看到—-urlAlphabet是一个长度为64的字符串。这里作者通过使用缓冲区中填充的随机数字, 将其与63进行按位与，生成0-63内的随机数字，作为一个随机字符，最终遍历结束得到一个size长度的随机字符串。\n1 2 3  import { nanoid } from 'nanoid' model.id = nanoid() / //=\u003e \"Uakgb_J5m9g-0JDMbcJqL\"   ","description":"","tags":null,"title":"nanoid源码解读I","uri":"/posts/nanoid%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBi/"},{"categories":null,"content":"序言  回首2021,对我来说,这既是充满希望的一年,也是失落慢慢的一年.下面就对我这2021一年的生活做一个总结,同时展望2022.\n 回首2021 2021年特殊之处在于,在2021年,我正式踏入了社会,摆脱了学生身份,现在转转公司工作,如果你没听说过转转的话,你应该听说过阿里的闲鱼,转转和闲鱼类似,针对的市场也是二手市场.而在这一年,职场生活给我的体验是明显不同于学生时代的.\n在职场中,一个关键词就是产出,我们作为员工的产出率是不是让上级满意,很大程度上决定了你的升职加薪等等,幸运的是,我在入职转转的时候,加入一个在我现在看来十分适合我的小组,据后来听大领导说,当时校招生分配小组时,80%是考虑小组是否缺人,20%是考虑个人能力是否符合. 因此我最终加入了现在的小组,果然在工作1月后,就有小组内的一位同事离职了.\n不扯远了,那下面就总结一下2021的结果.\n 成功融入团队 开始认真考虑理财,跑赢通货膨胀 开始锻炼,开始减肥 做一个自律的人 读5本技术书籍,1.5/5 输出读书笔记 开始学习Go  2021自省  在2021年我最大的问题就是不够自律, 空闲的时间或可以运动或可以学习来提高自己,但却白白浪费在了娱乐上,沉迷在无聊的事情中,回顾过去的时候,却又深深厌恶,却又一次次的再次沉迷. 这个问题需要重视,重视身心健康 而不应该隐藏在黑暗的角落中.\n 展望2022  在2022年,排在首位的问题就是提高自律,抛弃无聊的娱乐,时代变化的太快了,如果不断沉迷在低级娱乐中,当抬头的时候才发现已经远远落后于其他人, 因此2022年的计划如下(以下的学会指的是熟悉,而不是精通):\n  阅读5本技术书籍 0/5 学会并能够使用React 学会Go 接触开源项目(Go相关),尝试第一次PR做出贡献 继续锻炼,目标减重5公斤 自律,重视身心健康 将后续的技术总结,书籍笔记,生活感悟发到本博客上 接触一下函数编程–elixir  ","description":"","tags":null,"title":"2021年度总结","uri":"/posts/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"}]